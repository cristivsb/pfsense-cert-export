#!/usr/bin/env bash
set -euo pipefail

# -------- Settings --------
CONFIG_XML="${1:-/conf/config.xml}"
OUT_DIR="${OUT_DIR:-./exported}"
mkdir -p "$OUT_DIR"

# -------- Preflight --------
need() { command -v "$1" >/dev/null 2>&1 || { echo "[!] Missing command: $1" >&2; exit 1; }; }
need xmllint; need openssl; need base64
[[ -f "$CONFIG_XML" ]] || { echo "[!] Config not found: $CONFIG_XML" >&2; exit 1; }
if grep -q "<encrypted>" "$CONFIG_XML"; then
  echo "[!] Encrypted OPNsense backup. Decrypt/restore in Web UI first."; exit 1
fi

# -------- Helpers --------
sanitize() { echo "$1" | tr -c 'A-Za-z0-9._-+' '_' | sed 's/^_//; s/_$//'; }
b64_to_file() { printf "%s" "$1" | tr -d '\n\r\t ' | base64 -d > "$2"; }
xget() { xmllint --xpath "string($1)" "$CONFIG_XML" 2>/dev/null || true; }

# Enumerations by index (1-based)
cert_refid_by_index() { xmllint --xpath "//cert/refid/text()" "$CONFIG_XML" 2>/dev/null | tr ' \t\r\n' '\n' | sed '/^$/d' | sed -n "${1}p"; }
ca_refid_by_index()   { xmllint --xpath "//ca/refid/text()"   "$CONFIG_XML" 2>/dev/null | tr ' \t\r\n' '\n' | sed '/^$/d' | sed -n "${1}p"; }
all_ca_refids()       { xmllint --xpath "//ca/refid/text()"   "$CONFIG_XML" 2>/dev/null | tr ' \t\r\n' '\n' | sed '/^$/d'; }

expand_selection() {  # "1,3-5,9"
  local sel="${1// /}"
  awk -v sel="$sel" 'BEGIN{n=split(sel,a,","); for(i=1;i<=n;i++){ if(a[i]~/^[0-9]+-[0-9]+$/){split(a[i],r,"-"); s=r[1]; e=r[2]; step=(s<=e)?1:-1; for(j=s; (step>0? j<=e : j>=e); j+=step) print j } else if(a[i]~/^[0-9]+$/){ print a[i] } }}'
}

# --- X.509 helpers for CA entries by refid ---
_ca_tmp_pem() {  # prints temp filename
  local ref="$1"; local b64; b64=$(xget "//ca[refid='$ref']/crt"); local t; t=$(mktemp); b64_to_file "$b64" "$t"; echo "$t";
}
ca_subject_dn() { local t=$(_ca_tmp_pem "$1"); openssl x509 -in "$t" -noout -subject 2>/dev/null | sed 's/^subject= *//' || true; rm -f "$t"; }
ca_issuer_dn()  { local t=$(_ca_tmp_pem "$1"); openssl x509 -in "$t" -noout -issuer  2>/dev/null | sed 's/^issuer= *//'  || true; rm -f "$t"; }
ca_self_signed() {
  local ref="$1"; local ts ti; ts=$(ca_subject_dn "$ref"); ti=$(ca_issuer_dn "$ref")
  [[ -n "$ts" && "$ts" = "$ti" ]]
}

# Prefer explicit parent via <caref>; otherwise match Issuer==Subject
parent_ca_refid() {
  local child="$1"
  local parent
  parent=$(xget "//ca[refid='$child']/caref")
  if [[ -n "$parent" ]]; then echo "$parent"; return 0; fi
  # Fallback: DN match
  local issuer; issuer=$(ca_issuer_dn "$child"); [[ -z "$issuer" ]] && { echo ""; return 0; }
  local r
  while read -r r; do
    [[ -z "$r" || "$r" = "$child" ]] && continue
    local subj; subj=$(ca_subject_dn "$r")
    if [[ -n "$subj" && "$subj" = "$issuer" ]]; then echo "$r"; return 0; fi
  done < <(all_ca_refids)
  echo ""
}

# -------- Listing --------
list_ca() {
  echo "CA Certificates:"
  local idx=0
  while read -r ref; do
    [[ -z "$ref" ]] && continue
    idx=$((idx+1))
    local descr crt_b64 tmp cn until
    descr=$(xget "//ca[refid='$ref']/descr")
    crt_b64=$(xget "//ca[refid='$ref']/crt")
    tmp=$(mktemp); b64_to_file "$crt_b64" "$tmp"
    cn=$(openssl x509 -in "$tmp" -noout -subject 2>/dev/null | sed -n 's/.*CN=\([^,/]*\).*/\1/p')
    until=$(openssl x509 -in "$tmp" -noout -enddate 2>/dev/null | cut -d= -f2); rm -f "$tmp"
    printf "  %2d) %s\n      refid: %s\n      CN: %s\n      notAfter: %s\n" "$idx" "${descr:-"(no descr)"}" "$ref" "${cn:-"-"}" "${until:-"-"}"
  done < <(all_ca_refids)
}

list_cert() {
  echo "Certificates:"
  local idx=0
  while read -r ref; do
    [[ -z "$ref" ]] && continue
    idx=$((idx+1))
    local descr caref crt_b64 prv_b64 tmp cn until has_key ca_name
    descr=$(xget "//cert[refid='$ref']/descr")
    caref=$(xget "//cert[refid='$ref']/caref")
    crt_b64=$(xget "//cert[refid='$ref']/crt")
    prv_b64=$(xget "//cert[refid='$ref']/prv")
    tmp=$(mktemp); b64_to_file "$crt_b64" "$tmp"
    cn=$(openssl x509 -in "$tmp" -noout -subject 2>/dev/null | sed -n 's/.*CN=\([^,/]*\).*/\1/p')
    until=$(openssl x509 -in "$tmp" -noout -enddate 2>/dev/null | cut -d= -f2); rm -f "$tmp"
    has_key="no"; [[ -n "$prv_b64" ]] && has_key="yes"
    ca_name="-"; [[ -n "$caref" ]] && { ca_name=$(xget "//ca[refid='$caref']/descr"); [[ -z "$ca_name" ]] && ca_name="$caref"; }
    printf "  %2d) %s\n      refid: %s\n      CN: %s\n      notAfter: %s\n      private key: %s\n      CA: %s\n" \
      "$idx" "${descr:-"(no descr)"}" "$ref" "${cn:-"-"}" "${until:-"-"}" "$has_key" "${ca_name:-"-"}"
  done < <(xmllint --xpath "//cert/refid/text()" "$CONFIG_XML" 2>/dev/null | tr ' \t\r\n' '\n' | sed '/^$/d')
}

# -------- Chain writers --------
append_ca_chain() {
  # $1 = starting CA refid, $2 = include_root (0/1)
  local ref="$1" include_root="$2"
  local seen=" $ref "

  while [[ -n "$ref" ]]; do
    local t; t=$(_ca_tmp_pem "$ref")
    local self=0; ca_self_signed "$ref" && self=1

    if [[ "$self" -eq 1 && "$include_root" -eq 0 ]]; then
      rm -f "$t"; break  # stop before appending root
    fi

    echo              # newline separator
    cat "$t"; rm -f "$t"

    # Move to parent
    local parent; parent=$(parent_ca_refid "$ref")
    [[ -z "$parent" ]] && break
    # guard against loops
    if [[ " $seen " == *" $parent "* ]]; then break; fi
    seen+=" $parent "
    ref="$parent"
  done
}

write_bundle_chain() {
  # $1=cert_b64, $2=caref, $3=include_root (0/1)
  local cert_b64="$1" caref="$2" include_root="$3"
  local tmpc; tmpc=$(mktemp); b64_to_file "$cert_b64" "$tmpc"; cat "$tmpc"; rm -f "$tmpc"
  [[ -n "$caref" ]] && append_ca_chain "$caref" "$include_root"
}

# -------- Extraction --------
extract_cert_by_number() {
  local num="$1" mode="$2"  # crt|key|bundle|fullchain|all
  local ref; ref=$(cert_refid_by_index "$num" || true)
  [[ -z "$ref" ]] && { echo "  [!] Invalid cert number: $num"; return; }

  local descr caref crt_b64 prv_b64 safe base
  descr=$(xget "//cert[refid='$ref']/descr")
  caref=$(xget "//cert[refid='$ref']/caref")
  crt_b64=$(xget "//cert[refid='$ref']/crt")
  prv_b64=$(xget "//cert[refid='$ref']/prv")
  safe=$(sanitize "${descr:-cert}"); base="$OUT_DIR/${safe}_${ref}"

  case "$mode" in
    crt)
      b64_to_file "$crt_b64" "${base}.crt.pem"; echo "  [+] Wrote ${base}.crt.pem" ;;
    key)
      if [[ -n "$prv_b64" ]]; then
        b64_to_file "$prv_b64" "${base}.key.pem"; chmod 600 "${base}.key.pem" || true
        echo "  [+] Wrote ${base}.key.pem"
      else
        echo "  [!] No private key available for ${descr:-$ref}"
      fi
      ;;
    bundle)    # standard: omit root
      write_bundle_chain "$crt_b64" "$caref" 0 > "${base}.bundle.pem"
      echo "  [+] Wrote ${base}.bundle.pem"
      ;;
    fullchain) # include root
      write_bundle_chain "$crt_b64" "$caref" 1 > "${base}.fullchain.pem"
      echo "  [+] Wrote ${base}.fullchain.pem"
      ;;
    all)
      b64_to_file "$crt_b64" "${base}.crt.pem"; echo "  [+] Wrote ${base}.crt.pem"
      if [[ -n "$prv_b64" ]]; then
        b64_to_file "$prv_b64" "${base}.key.pem"; chmod 600 "${base}.key.pem" || true
        echo "  [+] Wrote ${base}.key.pem"
      else
        echo "  [!] No private key available for ${descr:-$ref}"
      fi
      write_bundle_chain "$crt_b64" "$caref" 0 > "${base}.bundle.pem";   echo "  [+] Wrote ${base}.bundle.pem"
      write_bundle_chain "$crt_b64" "$caref" 1 > "${base}.fullchain.pem"; echo "  [+] Wrote ${base}.fullchain.pem"
      ;;
  esac
}

extract_ca_by_number() {
  local num="$1"
  local ref; ref=$(ca_refid_by_index "$num" || true)
  [[ -z "$ref" ]] && { echo "  [!] Invalid CA number: $num"; return; }
  local descr crt_b64 safe out
  descr=$(xget "//ca[refid='$ref']/descr")
  crt_b64=$(xget "//ca[refid='$ref']/crt")
  safe=$(sanitize "${descr:-ca}")
  out="$OUT_DIR/${safe}_${ref}.ca.pem"; b64_to_file "$crt_b64" "$out"
  echo "  [+] Wrote $out"
}

# -------- Menus --------
extract_menu() {
  cat <<'EOF'

Extract options:
1) Extract CERTs (by number) -> .crt.pem
2) Extract CERT private keys  -> .key.pem
3) Extract CERT bundles       -> .bundle.pem (server + intermediates, omit root)
4) Extract CERT full chains   -> .fullchain.pem (server + intermediates + root)
5) Extract CERT full set      -> .crt.pem + .key.pem + .bundle.pem + .fullchain.pem
6) Extract CA certs           -> .ca.pem
0) Back to main menu

EOF
  read -r -p "Choose an option: " ans
  case "$ans" in
    1) list_cert; read -r -p "Enter cert numbers (e.g. 1,3-5): " sel;
       expand_selection "$sel" | while read -r i; do extract_cert_by_number "$i" "crt"; done; main_menu ;;
    2) list_cert; read -r -p "Enter cert numbers (e.g. 1,3-5): " sel;
       expand_selection "$sel" | while read -r i; do extract_cert_by_number "$i" "key"; done; main_menu ;;
    3) list_cert; read -r -p "Enter cert numbers (e.g. 1,3-5): " sel;
       expand_selection "$sel" | while read -r i; do extract_cert_by_number "$i" "bundle"; done; main_menu ;;
    4) list_cert; read -r -p "Enter cert numbers (e.g. 1,3-5): " sel;
       expand_selection "$sel" | while read -r i; do extract_cert_by_number "$i" "fullchain"; done; main_menu ;;
    5) list_cert; read -r -p "Enter cert numbers (e.g. 1,3-5): " sel;
       expand_selection "$sel" | while read -r i; do extract_cert_by_number "$i" "all"; done; main_menu ;;
    6) list_ca;   read -r -p "Enter CA numbers (e.g. 1,2,7-9): " sel;
       expand_selection "$sel" | while read -r i; do extract_ca_by_number "$i"; done; main_menu ;;
    0) main_menu ;;
    *) echo "Wrong option."; extract_menu ;;
  esac
}

main_menu() {
  cat <<'EOF'

Available options:
1) List CA Certificates
2) List Certificates
3) Extract Certificates/Keys/Bundles
0) Exit
Choose an option:
EOF
  read -r ans
  case $ans in
    1) list_ca;   main_menu ;;
    2) list_cert; main_menu ;;
    3) extract_menu ;;
    0) echo "Exiting Tool"; exit 0 ;;
    *) echo "Wrong option."; main_menu ;;
  esac
}

echo "[i] Output directory: $OUT_DIR"
main_menu
